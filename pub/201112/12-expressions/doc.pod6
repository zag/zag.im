=begin pod :pubdate('2011-12-12 10:00:00') :tags<grammars perl>

=TITLE Реализация приоритетности операторов с помощью грамматик Perl 5

=begin DESCRIPTION

С таблицей приоритетности сталкиваются в первую очередь дизайнеры языков программирования при проектировании, а так же те, кто затем изучает эти языки. 
Наиболее оптимальным способом реализовать приоритетность - совместить данный этап с построением синтаксического дерева.

=end DESCRIPTION

С таблицей приоритетности сталкиваются дизайнеры языков программирования на этапе проектирования, а так же те, кто затем изучает эти языки. 
Наиболее оптимальным способом реализовать приоритетность - совместить данный этап с построением синтаксического дерева. 

=head2 Таблица приоритетности операторов 

Приоритетность в математических ( и в любых других ) выражениях - вещь очень привычная. Для простого выражения:

    3 + 5 * 6 

сначала будет выполнена операция умножения, а затем - сложения. Синтаксическое дерево можно представить в следующем виде :

    +( *(5,6), 3 )

Возьмем пример с группирующими скобками. С их помощью можно влиять на порядок вычислений:

    ( 3 + 5 ) * 6 

Синтаксическое дерево будет выглядеть иначе:

    *( +(3,5), 6 )

Как видим группирующие скобки вносят корректировку в последовательность вычислений.

И еще один пример выражения:

    - (2 * -3)

в котором используется унарный оператор B<-> (минус) перед группирующей скобкой. Для него дерево будет следующее:

  -( *(2,-3) )

Унарный C<-> имеет более высокий приоритет по сравнению с C<*>.

Исходя из приведенных примеров можно составить таблицу приоритетов (I<3 - высший приоритет>):


=begin table :caption('Таблица приоритетов')
    приоритет    | оператор      | описание, действие 
  ===============+===============+=========
      1               +, -           сложение, вычитание
      2               *, /            операторы умножения, деления
      3               unary -       унарный минус
=end table

Грамматика, реализующая приоритетность, выглядит так:

=begin code :allow<B>
 my $q = qr{
     <expr>
    <rule: expr>
                # бинарные операции +-
                <a=mult> <op=([+-])> <b=expr> 
                | <MATCH=mult> 

    <rule: mult> 
                <a=term> <op=([*/])> <b=mult> 
                | <MATCH=term>

     <rule: term> 
              <MATCH=Digit> 
            | <Sign=([+-])> \( <expr>\) B<# unary->
            | \( <MATCH=expr> \)   B<# группирующие скобки>

    B<#токен, описывающий допустимый числовой агрумент>
    <token: Digit>
            [+-]? \d++ (?: \. \d++ )?+ 
    }xms;

=end code

Как видим поиск совпадений начинается с поиска наиболее приоритетного унарного минуса и учета группирующих скобок (токен I<term>), затем - операции C<*> и C</> (правило I<mult>) и т.д. 

=head2 Представление синтаксичеcкого дерева в памяти

Результат успешной работы грамматик (структура совпадений правил) сохраняется в переменной C<%/>. Отобразить результат можно следующим кодом:

    use Data::Dumper;
    my $t = q! 3 + 5 * 6 !;
    if ($t =~ $q) {
        print Dumper \%/;
    } else {
     warn "Error parse"
    }

Так, для исходного примера C< 3 + 5 * 6>, результат применения грамматик будет выглядеть следующим образом:

=begin code :allow<B>

      # 3 + 5 * 6 
      {
          'a' => '3', # первый аргумент - B<число>
          # второй аргумент - B<выражение>
          'b' => {    
                   'a' => '5',
                   'b' => '6',
                   'op' => '*'
                 },
          B<'op'> => '+' # B<оператор>
       };
=end code

Для выражения с унарным минусом:

=begin code :allow<B>
     #- (2 * -3)
     {
     'expr' => {
                  'a' => '2',
                  'b' => '-3',
                  'op' => '*'
                },
     B<'Sign'> => '-' 
     }
=end code

Чтобы полученные структуры можно было использовать как элементы синтаксического дерева, требуется ассоциировать с каждым правилом класс. Для этого достаточно заменить C<rule> на C<objrule> с указанием класса:

=begin code :allow<B>
    <B<objrule: ExpClass::mult>>  # объект оператора
                <a=term> <op=([*/])> <b=mult> 
                | <MATCH=term>
=end code

В результате мы получаем структуру объектов, построенную в соответствии с приоритетностью, определенной на уровне грамматик.

=end pod
