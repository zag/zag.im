=begin pod :pubdate('2012-06-19 10:00:00') :tags<webdao perl>
=NAME Жизнь без шаблонов

=begin DESCRIPTION

Я хотел бы поделиться впечатлениями после довольно продолжительного времени разработки 
без шаблонизаторов на бэкенде. История началась с отказа от Template::Toolkit на серверной стороне и переноса представления на сторону веб клиента.

=end DESCRIPTION

Я хотел бы поделиться впечатлениями после довольно продолжительного времени разработки
без шаблонизаторов на бэкенде. История началась с отказа от C<Template::Toolkit> на серверной стороне и переноса представления на сторону веб клиента N< Perl 5 модули, которые я использую реже и реже. L<http://zag.ru/b48j1>>. Вместе с представлением туда переместились и шаблоны, сохранив за собой право быть использованными и на серверной стороне N< Plosurin: Perl реализация Closure Templates. L<http://zag.ru/a4Fr1>>, но это отдельная тема. Сейчас, по истечении некоторого времени, очевидны стали следующие моменты.

=head2 Упростилась разработка бэкенда

На данный момент, по сути, серверная строна представляет собой API с авторизацией для доступа к данным, а форматы вывода: JSON, JSONP и XML. Ниже я приведу пример кода, который определяет
требуемый формат вывода и форматирует результаты. Код написан для «WebDAO» N< Платформа WebDAO для разработки web приложений на Perl 5. L<http://webdao.sourceforge.net/>>, но общий смысл, я постараюсь передать в комментариях:

=begin code :allow(B)
package MyApp;
use WebDAO;
use base 'WebDAO::Engine';
use JSON;
use XML::Simple;

# пример метода 
# он отображается на url /Test
 sub Test {
    { 
        1 => 2,
        error => 0 
    }
 }

# этот метод обрабатывает http запросы
 sub _traverse_  {
    my $self = shift;
    my ( $src, $res ) = $self->SUPER::_traverse_( @_ );
    # $src - объект обработавший запрос
    # B<$res - результат вызова метода>
    if ( B«ref($res) eq 'HASH'» ) {
        my $r = $self->response();

        # B«$r->wantformat» возвращает true если
        # присутствует параметр format=xml или 
        # путь заканчивается на B<.xml>
        # например: http://example.com/api/get1&format=xml, 
        # http://example.com/api/get1.xml

        if ($r->wantformat('xml') ) { B<#xml>

            $r->content_type('appliction/xml;charset=UTF-8');
            $r->print(XMLout( $res ))

        } else {  # default 'json' 

            $r->content_type('text/javascript;charset=UTF-8');
            # B«параметр pretty => 1 для форматированного JSON»
	    $r->print(to_json($res, {utf8 => 1, pretty => 1}))
        }
        $r->flush;
        $r->_destroy;
        $r->set_empty();
        return (undef, $r) ;  #return empty response
    }
    return ( $src, $res );
 }
1;
=end code 

Данный код позволяет писать простые методы:

 sub Test {
    { 
        1 => 2,
        error => 0 
    }
 }

Достаточно вернуть в качестве ответа ссылку на хэш и преобразование к требуемому
формату будет выполнено автоматически.

Следующим и, пожалуй, наиболее эффектным последствием отказа от шаблонизаторов на бэкенде
стала возможность разрабатывать без веб сервера и браузера. 
Текстовые форматы JSON и XML хорошо читаются без дополнительных программ и хорошо воспринимаются при отображении в консоли. 

Поэтому увидеть результат запроса просто:

   wd_shell -M MyApp /Test

Результат:

  {
   "1" : 2,
   "error" : 0
  }

Тоже с параметрами:

   wd_shell -M MyApp '/Test?format=xml'

Результат:

    <opt 1="2" error="0" />

Таким образом значительно упрощается среда разработки и время необходимое 
для развертывания окружения.


=head2 «Кесарю кесарево» N< Кесарю кесарево. L<http://ru.wikipedia.org/wiki/Кесарю кесарево|http://ru.wikipedia.org/wiki/%D0%9A%D0%B5%D1%81%D0%B0%D1%80%D1%8E_%D0%BA%D0%B5%D1%81%D0%B0%D1%80%D0%B5%D0%B2%D0%BE>>

Шаблоны были неким общим «местом встречи» фронтенд и бэкенд разработчиков. Файлы шаблонов редактировали одни и вторые. С одной стороны, серверсайд программисты проникались чувством прекрасного посредством копипасты кусков html и css, а с другой стороны – дизайнеры и javascript разработчики, вынуждены были знать дополнительный серверный язык шаблонов I<( и быть в некоторой зависимости от принятых правил деплоя )>.

На данный момент единственным связующим фронтенд и бэкенд разарботку 
является API, который структурирован, может быть формализован и документирован. Это делает разработку динамичнее благодаря отсутствию общих точек, где возможны «блокировки», и определяет четкие границы ответственности.

=head2 Итог

Не факт, что избавление от шаблонизаторов на стороне сервера - универсальный
рецепт на все случаи жизни. Но для некоторых проектов использование
подобного подхода -  хороший способ упростить разработку и даже начать экпериментировать с разными технологиями бэкендов.

К тому же, этот API может стать хорошим стартом для создания публичного API сервиса.

=end pod
